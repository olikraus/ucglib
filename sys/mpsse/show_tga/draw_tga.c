
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "ucg.h"
#include "draw_tga.h"

int draw_image(ucg_t *ucgPtr, const char *name) {
    int ret_val = 0;
    if (tga_open(name) != 0) {
        if (tga_read_header() != 0) {
            while (tga_read_write_pixel(ucgPtr) != 0);
        } else {
            ret_val = 1;
        }
        tga_close();
    } else {
        ret_val = 1;
    }
    return ret_val;
}


#ifdef __unix__
FILE *f;

uint8_t tga_read_byte(void) {
    return fgetc(f);
}

void tga_read_buf(uint8_t *buf, uint16_t len) {
    uint16_t i;
    for (i = 0; i < len; i++)
        buf[i] = tga_read_byte();
}

uint8_t tga_open(const char *name) {
    f = fopen(name, "rb");
    if (f != NULL)
        return 1;
    return 0;
}

void tga_close(void) {
    if (f != NULL) {
        fclose(f);
    }
}

#else
/* use Arduino SD library*/
const int sd_chip_select = 10;

File tga_file;

uint8_t tga_read_byte(void) {
    return tga_file.read();
}

void tga_read_buf(uint8_t *buf, uint16_t len) {
    uint16_t i;
    for (i = 0; i < len; i++)
        buf[i] = tga_read_byte();
}

uint8_t tga_open(const char *name) {
    tga_file = SD.open(name, O_RDONLY);
    if (tga_file)
        return 1;
    return 0;
}

void tga_close(void) {
    if (tga_file) {
        tga_file.close();
    }
}
#endif


static uint16_t tga_width;
static uint16_t tga_height;
static uint16_t tga_x;
static uint16_t tga_y;

uint16_t tga_read_word(void) {
    uint16_t v;
    v = tga_read_byte();
    v |= tga_read_byte() << 8;
    return v;
}

/* read header as generated by gimp without RLE */
uint8_t tga_read_header(void) {
    uint8_t v, i;
    tga_x = 0; /* reset draw position */
    tga_y = 0;
    v = tga_read_byte(); /* Imgae ID field, must be 0 */
    if (v != 0) return 0;
    v = tga_read_byte(); /* Color map type, must be 0 */
    if (v != 0) return 0;
    v = tga_read_byte(); /* Image type, must be 2, uncompressed true color */
    if (v != 2) return 0;
    for (i = 0; i < 9; i++)
        tga_read_byte(); /* skip color map and origin */
    tga_width = tga_read_word();
    tga_height = tga_read_word();
    v = tga_read_byte(); /* bits per pixel, must be 24, true color */
    if (v != 24) return 0;
    v = tga_read_byte(); /* image descriptor, must be 0, no alpha */
    if (v != 0) return 0;
    return 1;
}

//#define TGA_PIX_BUF_SIZE 64
#define TGA_PIX_BUF_SIZE 256
static uint8_t tga_pixel[3 * TGA_PIX_BUF_SIZE];

uint8_t tga_read_write_pixel(ucg_t *ucgPtr) {
    uint16_t i;
    uint8_t *buf;
    
    buf = tga_pixel;
    tga_read_buf(tga_pixel, 3 * TGA_PIX_BUF_SIZE);
    for (i = 0; i < TGA_PIX_BUF_SIZE; i++) {
        ucg_SetColor(ucgPtr, 0, buf[2], buf[1], buf[0]);
        buf += 3;
        ucg_DrawPixel(ucgPtr, tga_x, ucg_GetHeight(ucgPtr) - 1 - tga_y);
        tga_x++;
        if (tga_x >= tga_width) {
            tga_x = 0;
            tga_y++;
            if (tga_y > tga_height)
                return 0;
        }
    }
    return 1;
}

